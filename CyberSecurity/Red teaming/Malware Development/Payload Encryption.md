There are various techniques to hide the malicious file. One of that is use various encryption algorithms to conceal the malicious code making it more difficult for security solutions to detect the activity of the file.

## Encryption Pros and Cons

| Pros                            | Cons                                                                                                                                                                                                                                                                                        |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Evade signature-based detection | More data that's ecrypted within file the higher its entropy.Having a file with a high [entropy](https://practicalsecurityanalytics.com/file-entropy/) score can cause security solutions to flag the file or at the very least consider it suspicious and place additional scrutiny on it. |

## Encryption Types

The upcoming modules will go through three of the most widely used encryption algorithms in malware development:

- XOR
- AES
- RC4

# XOR Encryption

The code snippet below shows a basic XOR encryption function. The function simply XORs each byte of the shellcode with a 1-byte key.
```rust
fn xor_by_one_key(shellcode: &mut Vec<u8>, key:u8){
    for byte in shellcode.iter_mut(){
        *byte ^= key;
    }
}
```

## Securing The Encryption Key

Some tools and security solutions can brute force the key which will expose the decrypted shellcode. To make the process of guessing the key more difficult for these tools, the code below performs a minor change and increases the keyspace of the key by making `i` a part of the key. With keyspace much larger now, it's more difficult to brute force the key.
```rust
fn xor_by_i_key(shellcode: &mut Vec<u8>, key:u8){
    for(i,byte) in shellcode.iter_mut().enumerate(){
        *byte ^= key.wrapping_add(i as u8);
    }
}
```

The code snippet above can still be hardened further. The snippet below performs the encryption process with a key, using every byte of the key repeatedly making it harder to crack the key.

```rust
fn xor_by_input_key(shellcode: &mut Vec<u8>, key: &[u8]) {
   for(i,byte) in shellcode.iter_mut().enumerate(){
    let key_index = i % key.len();
    *byte ^= key[key_index];
   }
}
```

## Conclusion

It is recommended to utilize XOR encryption **for small tasks**, such as obscuring strings. However, for larger payloads, it is advised to use more secure encryption methods such as AES.