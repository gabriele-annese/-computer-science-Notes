BOFs are lightweight post-exploitation tools that can be ran inside of a Beacon process.  They offer a distinct tradecraft advantage over legacy post-ex methods like Cobalt Strike’s fork&run mechanism (which spawns a new process to run the specified code), and are generally far less cumbersome than reflective DLLs or .NET programs.  Of course nothing is free; alongside the benefits that BOFs offer comes the risk of crashing your Beacon process should your BOF not perform as expected.

"Post-exploitation tool" is a very broad description, and for good reason.  BOFs can perform actions as simple as retrieving and printing the current working directory, and one’s complex enough to involve dropping a vulnerable driver to disk in order to manipulate protected processes.  As Antivirus (AV) and Endpoint Detection and Response (EDR) software has become more robust and capable, BOFs have also arisen as replacements for common programs like netstat.exe, whoami.exe, and tasklist.exe.  By leveraging the Windows API the same information can be gathered without invoking these legitimate, but unusual for everyday users, binaries.

BOFs follow the Common Object File Format (COFF) specification which is described in detail by Microsoft [here](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format).  The technical details are enough to make most people’s eyes glaze over, so for simplicity we will refer to [TrustedSec](https://trustedsec.com/)’s article [BOFs for Script Kiddies](https://trustedsec.com/blog/bofs-for-script-kiddies) which helpfully explains that:

> [!TIP]
> COFF describes the layout for object files which are the compiled binary files that are linked together to produce a PE binary.  Therefore, COFF files are the result of compiling C/C++ files, AKA: your basic .o/.obj files.

Being .o files, BOFs are not linked.  This means that we cannot call Windows or C-standard APIs like one normally would when writing a windows executable(.exe).  BOFs rely on Beacon to serve as the linker, google for resolving APIs used by the BOF and ultimately executing the code.  The specifics of how BOFs must be written to comply with this limitation will be detailed later on in the course.

From a timeline perspective, BOFs arrived on the scene in 2020 with the release of Cobalt Strike version 4.1.  They have since flourished, not only in the number of BOFs available publicly on GitHub and other platforms, but also because many other C2 frameworks have added support for BOFs.  As of early 2024, the list of other C2s that support BOFs includes Meterpreter, Mythic, Havoc, Sliver, Empire, Brute Ratel, Nighthawk, and a number of others that I won’t mention for the sake of brevity.

Even with this expansion of support, the Cobalt Strike BOF standard still reigns supreme; most BOFs include the use of Cobalt Strike-specific Beacon APIs to do things like return output from the BOF to the C2 server, and usually come paired with an Aggressor script (more on these later) to better integrate the BOF into Cobalt Strike.  Many of the C2s listed above have developed support for these APIs so that BOFs developed for Cobalt Strike may be used without modification, but others require some massaging and modification of the BOF to be compatible.

BOFs are so prolific these days that if you have an idea for one there is a very good chance that it already exists.  TrustedSec has contributed a ton to the community with their [CS-Situational-Awareness-BOF](https://github.com/trustedsec/CS-Situational-Awareness-BOF) and [CS-Remote-Ops-BOF](https://github.com/trustedsec/CS-Remote-OPs-BOF) repos which boast a combined ~100 BOFs that range from a netstat.exe replacement to one that can collect Microsoft Office authentication tokens from running Office processes like Word and Excel.  They are far from the only ones on the scene however, with Outflank publishing their [C2-Tool-Collection](https://github.com/outflanknl/C2-Tool-Collection) of ~20 BOFs and REDMED-X’s [OperatorsKit](https://github.com/REDMED-X/OperatorsKit) providing an additional ~30.

Companies/organizations do not have a monopoly here, with individual contributors regularly releasing BOFs for all manner of things.  The time between a new exploit or POC dropping on X (Twitter) and someone releasing a BOF version of it has increasingly shrunk, a trend that I anticipate will continue given how widespread the adoption of BOFs for post-ex capabilities has become.